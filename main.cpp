//Для заданного подмножества набора костей домино определить, можно ли их выложить в ряд, не нарушая правил.
//Если можно, то представить один любой вариант такого разложения. Например, для входных данных 31, 00, 13,
//получаем ответ: некорректные входные данные; для входных данных 02, 04, 42 ответ: можно, 04, 42, 20.
//Использовать двухсвязный список.
#include "header.h"
int main() {
    Dominode* head = nullptr;//начало списка
    cout<<"Составление домино в ряд (ИКМ C++, зад. 6)\nВведите количество костей домино (от 2 и больше): ";
    string nstring; cin>>nstring;
    
    //проверка на д***ка (неопытного пользователя)
    
    if (!isNumber(nstring)){//проверяем, является ли число положительным номером
        cout<<"Данные не являются числом или число отрицательное";
        exit(0);
    }
    if (nstring=="0"||nstring=="1"){//проверяем, число больше 2 или нет
        cout<<"Для составления ряда нужно две кости или больше";
        exit(0);
    }
    if (nstring.size()>15){//проверяем, если число имеет больше 15 цифр (чтобы не перейти лимит типа int)
        cout<<"Число костей слишком большое";
        exit(0);
    }
    unsigned long long int n=stoi(nstring);//количество костей
    for (int i=0; i<n; i++){
        //вводим паттерны для каждой половинки каждой кости домино и сразу добавляем их в список
        cout<<"Введите количество точек на первой половине "<<i+1<<"-й кости: ";
        string temp; cin>>temp;
        if (!dominoCheck(temp)){//проверяем, является ли число номером от 0 до 6
            cout<<"Количество точек может быть только от 0 до 6 включительно.";
            exit(0);
        }
        int first=stoi(temp);
        cout<<"Введите количество точек на второй половине "<<i+1<<"-й кости: ";
        cin>>temp;
        if (!dominoCheck(temp)){//проверяем, опять
            cout<<"Количество точек может быть только от 0 до 6.";
            exit(0);
        }
        int second=stoi(temp);
        addDomino(head, first, second);
    }
    //if (canArrangeDominoes(head)) {
    //    cout << "Можно уложить кости так: ";
    //    while (head!=NULL){
    //        cout<<head->first<<head->second<<" ";
    //        head=head->next;
    //    }
    //}else{
    //    cout << "Невозможно расставить кости в ряд" << endl;
    //}
    //freeDominoList(head);//освобождаем память
    arrangeDominoes(head,n);//считаем, можно ли сделать ряд; если да, то выводим
}